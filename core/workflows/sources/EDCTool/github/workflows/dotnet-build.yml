name: .NET Build, Test, and Security Scan

on:
  push:
    branches: [ master, condescending-clarke ]
  pull_request:
    branches: [ master ]

env:
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-test:
    name: Build and Test
    runs-on: windows-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for better analysis

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: dotnet restore

    - name: Build solution
      run: dotnet build --no-restore --configuration Release

    - name: Run unit tests
      run: dotnet test --no-build --configuration Release --verbosity normal --collect:"XPlat Code Coverage" --results-directory ./coverage

    - name: Upload coverage reports to Codecov
      uses: codecov/codecov-action@v4
      with:
        directory: ./coverage
        fail_ci_if_error: false
        flags: unittests
        name: codecov-edctoolkit

    - name: Generate coverage report
      run: |
        dotnet tool install -g dotnet-reportgenerator-globaltool
        reportgenerator -reports:./coverage/**/coverage.cobertura.xml -targetdir:./coverage/report -reporttypes:Html
      continue-on-error: true

    - name: Upload coverage report artifact
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: ./coverage/report
      if: always()

  security-scan:
    name: Security Scan
    runs-on: windows-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore dependencies
      run: dotnet restore

    - name: Run security scan
      run: |
        dotnet list package --vulnerable --include-transitive 2>&1 | Tee-Object -FilePath security-scan.txt
      continue-on-error: true

    - name: Check for hardcoded secrets
      run: |
        echo "Scanning for hardcoded credentials..."
        # Use double-quoted strings with backtick escaping for regex patterns
        $patterns = @(
          "Password\s*=\s*[`"'][^`"']+[`"']",
          "pwd\s*=\s*[`"'][^`"']+[`"']",
          "ConnectionString\s*=\s*.*Password\s*=\s*[^;`"'YOUR_]+",
          "ApiKey\s*=\s*[`"'][^`"']+[`"']",
          "Secret\s*=\s*[`"'][^`"']+[`"']"
        )

        $found = $false
        foreach ($pattern in $patterns) {
          $results = Get-ChildItem -Path . -Include *.cs,*.config,*.json -Recurse -ErrorAction SilentlyContinue |
            Select-String -Pattern $pattern -ErrorAction SilentlyContinue

          if ($results) {
            Write-Host "WARNING: Potential hardcoded credential found:"
            $results | ForEach-Object { Write-Host $_.Path ":" $_.LineNumber }
            $found = $true
          }
        }

        if ($found) {
          Write-Host "SECURITY ISSUE: Hardcoded credentials detected!"
          exit 1
        } else {
          Write-Host "No hardcoded credentials found"
        }

    - name: Check for SQL injection patterns
      run: |
        echo "Scanning for potential SQL injection vulnerabilities..."
        $pattern = 'new SqlCommand\([^@]*\+|new SqlDataAdapter\([^@]*\+|ExecuteNonQuery\([^@]*\+'

        $matches = Get-ChildItem -Path . -Include *.cs -Recurse -ErrorAction SilentlyContinue |
          Select-String -Pattern $pattern -ErrorAction SilentlyContinue |
          Where-Object { $_.Line -notmatch '\/\/.*' }  # Exclude commented lines

        if ($matches) {
          Write-Host "⚠️ WARNING: Potential SQL injection pattern found:"
          $matches | ForEach-Object { Write-Host $_.Path ":" $_.LineNumber }
          Write-Host "Please review these patterns and ensure parameterized queries are used."
        } else {
          Write-Host "✅ No obvious SQL injection patterns found"
        }
      continue-on-error: true

    - name: Upload security scan results
      uses: actions/upload-artifact@v4
      with:
        name: security-scan-results
        path: security-scan.txt
      if: always()

  code-quality:
    name: Code Quality Analysis
    runs-on: windows-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore dependencies
      run: dotnet restore

    - name: Build with analyzers
      run: dotnet build --no-restore --configuration Release /p:EnforceCodeStyleInBuild=true /p:TreatWarningsAsErrors=false

    - name: Run code analysis
      run: |
        echo "Code Quality Metrics:"
        echo "===================="

        # Count lines of code
        $csFiles = Get-ChildItem -Path . -Include *.cs -Recurse -ErrorAction SilentlyContinue |
          Where-Object { $_.FullName -notmatch '\\obj\\|\\bin\\|Designer\.cs|\.g\.cs' }

        $totalLines = ($csFiles | Get-Content | Measure-Object -Line).Lines
        $fileCount = $csFiles.Count

        Write-Host "C# Files: $fileCount"
        Write-Host "Total Lines: $totalLines"
        Write-Host "Avg Lines/File: $([math]::Round($totalLines / $fileCount, 0))"

        # Count God Objects (files > 500 lines)
        $godObjects = $csFiles | ForEach-Object {
          $lineCount = (Get-Content $_.FullName | Measure-Object -Line).Lines
          if ($lineCount -gt 500) {
            [PSCustomObject]@{
              File = $_.Name
              Lines = $lineCount
            }
          }
        }

        if ($godObjects) {
          Write-Host "`n⚠️ Files exceeding 500 lines (God Object anti-pattern):"
          $godObjects | Format-Table -AutoSize
        }

  build-status:
    name: Build Status Summary
    runs-on: windows-latest
    needs: [build-and-test, security-scan, code-quality]
    if: always()

    steps:
    - name: Check build status
      run: |
        echo "Build Summary"
        echo "============="
        echo "Build & Test: ${{ needs.build-and-test.result }}"
        echo "Security Scan: ${{ needs.security-scan.result }}"
        echo "Code Quality: ${{ needs.code-quality.result }}"

        if ("${{ needs.build-and-test.result }}" -ne "success") {
          Write-Host "❌ Build or tests failed"
          exit 1
        }

        if ("${{ needs.security-scan.result }}" -eq "failure") {
          Write-Host "❌ Security issues detected"
          exit 1
        }

        Write-Host "✅ All checks passed!"
